// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Gate/Protocol/GC.code.proto

#ifndef PROTOBUF_Gate_2fProtocol_2fGC_2ecode_2eproto__INCLUDED
#define PROTOBUF_Gate_2fProtocol_2fGC_2ecode_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMSG_G2C_HeartbeatImpl();
void InitDefaultsMSG_G2C_Heartbeat();
void InitDefaultsMSG_G2C_EncryptKeyImpl();
void InitDefaultsMSG_G2C_EncryptKey();
void InitDefaultsMSG_G2C_LoginImpl();
void InitDefaultsMSG_G2C_Login();
void InitDefaultsMSG_G2C_CreateRoleImpl();
void InitDefaultsMSG_G2C_CreateRole();
void InitDefaultsRole_BaseInfoImpl();
void InitDefaultsRole_BaseInfo();
void InitDefaultsRole_ModelImpl();
void InitDefaultsRole_Model();
void InitDefaultsRole_InfoImpl();
void InitDefaultsRole_Info();
inline void InitDefaults() {
  InitDefaultsMSG_G2C_Heartbeat();
  InitDefaultsMSG_G2C_EncryptKey();
  InitDefaultsMSG_G2C_Login();
  InitDefaultsMSG_G2C_CreateRole();
  InitDefaultsRole_BaseInfo();
  InitDefaultsRole_Model();
  InitDefaultsRole_Info();
}
}  // namespace protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto
namespace Protocol {
namespace Gate {
namespace G2C {
class MSG_G2C_CreateRole;
class MSG_G2C_CreateRoleDefaultTypeInternal;
extern MSG_G2C_CreateRoleDefaultTypeInternal _MSG_G2C_CreateRole_default_instance_;
class MSG_G2C_EncryptKey;
class MSG_G2C_EncryptKeyDefaultTypeInternal;
extern MSG_G2C_EncryptKeyDefaultTypeInternal _MSG_G2C_EncryptKey_default_instance_;
class MSG_G2C_Heartbeat;
class MSG_G2C_HeartbeatDefaultTypeInternal;
extern MSG_G2C_HeartbeatDefaultTypeInternal _MSG_G2C_Heartbeat_default_instance_;
class MSG_G2C_Login;
class MSG_G2C_LoginDefaultTypeInternal;
extern MSG_G2C_LoginDefaultTypeInternal _MSG_G2C_Login_default_instance_;
class Role_BaseInfo;
class Role_BaseInfoDefaultTypeInternal;
extern Role_BaseInfoDefaultTypeInternal _Role_BaseInfo_default_instance_;
class Role_Info;
class Role_InfoDefaultTypeInternal;
extern Role_InfoDefaultTypeInternal _Role_Info_default_instance_;
class Role_Model;
class Role_ModelDefaultTypeInternal;
extern Role_ModelDefaultTypeInternal _Role_Model_default_instance_;
}  // namespace G2C
}  // namespace Gate
}  // namespace Protocol
namespace Protocol {
namespace Gate {
namespace G2C {

// ===================================================================

class MSG_G2C_Heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocol.Gate.G2C.MSG_G2C_Heartbeat) */ {
 public:
  MSG_G2C_Heartbeat();
  virtual ~MSG_G2C_Heartbeat();

  MSG_G2C_Heartbeat(const MSG_G2C_Heartbeat& from);

  inline MSG_G2C_Heartbeat& operator=(const MSG_G2C_Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MSG_G2C_Heartbeat(MSG_G2C_Heartbeat&& from) noexcept
    : MSG_G2C_Heartbeat() {
    *this = ::std::move(from);
  }

  inline MSG_G2C_Heartbeat& operator=(MSG_G2C_Heartbeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_G2C_Heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MSG_G2C_Heartbeat* internal_default_instance() {
    return reinterpret_cast<const MSG_G2C_Heartbeat*>(
               &_MSG_G2C_Heartbeat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MSG_G2C_Heartbeat* other);
  friend void swap(MSG_G2C_Heartbeat& a, MSG_G2C_Heartbeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MSG_G2C_Heartbeat* New() const PROTOBUF_FINAL { return New(NULL); }

  MSG_G2C_Heartbeat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MSG_G2C_Heartbeat& from);
  void MergeFrom(const MSG_G2C_Heartbeat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MSG_G2C_Heartbeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 UId = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUIdFieldNumber = 1;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.Gate.G2C.MSG_G2C_Heartbeat)
 private:
  void set_has_uid();
  void clear_has_uid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 uid_;
  friend struct ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::TableStruct;
  friend void ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::InitDefaultsMSG_G2C_HeartbeatImpl();
};
// -------------------------------------------------------------------

class MSG_G2C_EncryptKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocol.Gate.G2C.MSG_G2C_EncryptKey) */ {
 public:
  MSG_G2C_EncryptKey();
  virtual ~MSG_G2C_EncryptKey();

  MSG_G2C_EncryptKey(const MSG_G2C_EncryptKey& from);

  inline MSG_G2C_EncryptKey& operator=(const MSG_G2C_EncryptKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MSG_G2C_EncryptKey(MSG_G2C_EncryptKey&& from) noexcept
    : MSG_G2C_EncryptKey() {
    *this = ::std::move(from);
  }

  inline MSG_G2C_EncryptKey& operator=(MSG_G2C_EncryptKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_G2C_EncryptKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MSG_G2C_EncryptKey* internal_default_instance() {
    return reinterpret_cast<const MSG_G2C_EncryptKey*>(
               &_MSG_G2C_EncryptKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MSG_G2C_EncryptKey* other);
  friend void swap(MSG_G2C_EncryptKey& a, MSG_G2C_EncryptKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MSG_G2C_EncryptKey* New() const PROTOBUF_FINAL { return New(NULL); }

  MSG_G2C_EncryptKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MSG_G2C_EncryptKey& from);
  void MergeFrom(const MSG_G2C_EncryptKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MSG_G2C_EncryptKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string EncryptKey = 1;
  bool has_encryptkey() const;
  void clear_encryptkey();
  static const int kEncryptKeyFieldNumber = 1;
  const ::std::string& encryptkey() const;
  void set_encryptkey(const ::std::string& value);
  #if LANG_CXX11
  void set_encryptkey(::std::string&& value);
  #endif
  void set_encryptkey(const char* value);
  void set_encryptkey(const char* value, size_t size);
  ::std::string* mutable_encryptkey();
  ::std::string* release_encryptkey();
  void set_allocated_encryptkey(::std::string* encryptkey);

  // @@protoc_insertion_point(class_scope:Protocol.Gate.G2C.MSG_G2C_EncryptKey)
 private:
  void set_has_encryptkey();
  void clear_has_encryptkey();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr encryptkey_;
  friend struct ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::TableStruct;
  friend void ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::InitDefaultsMSG_G2C_EncryptKeyImpl();
};
// -------------------------------------------------------------------

class MSG_G2C_Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocol.Gate.G2C.MSG_G2C_Login) */ {
 public:
  MSG_G2C_Login();
  virtual ~MSG_G2C_Login();

  MSG_G2C_Login(const MSG_G2C_Login& from);

  inline MSG_G2C_Login& operator=(const MSG_G2C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MSG_G2C_Login(MSG_G2C_Login&& from) noexcept
    : MSG_G2C_Login() {
    *this = ::std::move(from);
  }

  inline MSG_G2C_Login& operator=(MSG_G2C_Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_G2C_Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MSG_G2C_Login* internal_default_instance() {
    return reinterpret_cast<const MSG_G2C_Login*>(
               &_MSG_G2C_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MSG_G2C_Login* other);
  friend void swap(MSG_G2C_Login& a, MSG_G2C_Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MSG_G2C_Login* New() const PROTOBUF_FINAL { return New(NULL); }

  MSG_G2C_Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MSG_G2C_Login& from);
  void MergeFrom(const MSG_G2C_Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MSG_G2C_Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.Gate.G2C.Role_BaseInfo RoleList = 2;
  int rolelist_size() const;
  void clear_rolelist();
  static const int kRoleListFieldNumber = 2;
  const ::Protocol::Gate::G2C::Role_BaseInfo& rolelist(int index) const;
  ::Protocol::Gate::G2C::Role_BaseInfo* mutable_rolelist(int index);
  ::Protocol::Gate::G2C::Role_BaseInfo* add_rolelist();
  ::google::protobuf::RepeatedPtrField< ::Protocol::Gate::G2C::Role_BaseInfo >*
      mutable_rolelist();
  const ::google::protobuf::RepeatedPtrField< ::Protocol::Gate::G2C::Role_BaseInfo >&
      rolelist() const;

  // required int32 Result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.Gate.G2C.MSG_G2C_Login)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::Gate::G2C::Role_BaseInfo > rolelist_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::TableStruct;
  friend void ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::InitDefaultsMSG_G2C_LoginImpl();
};
// -------------------------------------------------------------------

class MSG_G2C_CreateRole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocol.Gate.G2C.MSG_G2C_CreateRole) */ {
 public:
  MSG_G2C_CreateRole();
  virtual ~MSG_G2C_CreateRole();

  MSG_G2C_CreateRole(const MSG_G2C_CreateRole& from);

  inline MSG_G2C_CreateRole& operator=(const MSG_G2C_CreateRole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MSG_G2C_CreateRole(MSG_G2C_CreateRole&& from) noexcept
    : MSG_G2C_CreateRole() {
    *this = ::std::move(from);
  }

  inline MSG_G2C_CreateRole& operator=(MSG_G2C_CreateRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_G2C_CreateRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MSG_G2C_CreateRole* internal_default_instance() {
    return reinterpret_cast<const MSG_G2C_CreateRole*>(
               &_MSG_G2C_CreateRole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MSG_G2C_CreateRole* other);
  friend void swap(MSG_G2C_CreateRole& a, MSG_G2C_CreateRole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MSG_G2C_CreateRole* New() const PROTOBUF_FINAL { return New(NULL); }

  MSG_G2C_CreateRole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MSG_G2C_CreateRole& from);
  void MergeFrom(const MSG_G2C_CreateRole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MSG_G2C_CreateRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Protocol.Gate.G2C.Role_BaseInfo Role = 2;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::Protocol::Gate::G2C::Role_BaseInfo& role() const;
  ::Protocol::Gate::G2C::Role_BaseInfo* release_role();
  ::Protocol::Gate::G2C::Role_BaseInfo* mutable_role();
  void set_allocated_role(::Protocol::Gate::G2C::Role_BaseInfo* role);

  // required int32 Result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.Gate.G2C.MSG_G2C_CreateRole)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_role();
  void clear_has_role();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Protocol::Gate::G2C::Role_BaseInfo* role_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::TableStruct;
  friend void ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::InitDefaultsMSG_G2C_CreateRoleImpl();
};
// -------------------------------------------------------------------

class Role_BaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocol.Gate.G2C.Role_BaseInfo) */ {
 public:
  Role_BaseInfo();
  virtual ~Role_BaseInfo();

  Role_BaseInfo(const Role_BaseInfo& from);

  inline Role_BaseInfo& operator=(const Role_BaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Role_BaseInfo(Role_BaseInfo&& from) noexcept
    : Role_BaseInfo() {
    *this = ::std::move(from);
  }

  inline Role_BaseInfo& operator=(Role_BaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role_BaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Role_BaseInfo* internal_default_instance() {
    return reinterpret_cast<const Role_BaseInfo*>(
               &_Role_BaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Role_BaseInfo* other);
  friend void swap(Role_BaseInfo& a, Role_BaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Role_BaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Role_BaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Role_BaseInfo& from);
  void MergeFrom(const Role_BaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Role_BaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .Protocol.Gate.G2C.Role_Model Model = 5;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 5;
  const ::Protocol::Gate::G2C::Role_Model& model() const;
  ::Protocol::Gate::G2C::Role_Model* release_model();
  ::Protocol::Gate::G2C::Role_Model* mutable_model();
  void set_allocated_model(::Protocol::Gate::G2C::Role_Model* model);

  // required int32 Id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 Sex = 3;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 3;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // required int32 Level = 4;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 4;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.Gate.G2C.Role_BaseInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_sex();
  void clear_has_sex();
  void set_has_level();
  void clear_has_level();
  void set_has_model();
  void clear_has_model();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Protocol::Gate::G2C::Role_Model* model_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 level_;
  friend struct ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::TableStruct;
  friend void ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::InitDefaultsRole_BaseInfoImpl();
};
// -------------------------------------------------------------------

class Role_Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocol.Gate.G2C.Role_Model) */ {
 public:
  Role_Model();
  virtual ~Role_Model();

  Role_Model(const Role_Model& from);

  inline Role_Model& operator=(const Role_Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Role_Model(Role_Model&& from) noexcept
    : Role_Model() {
    *this = ::std::move(from);
  }

  inline Role_Model& operator=(Role_Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role_Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Role_Model* internal_default_instance() {
    return reinterpret_cast<const Role_Model*>(
               &_Role_Model_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Role_Model* other);
  friend void swap(Role_Model& a, Role_Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Role_Model* New() const PROTOBUF_FINAL { return New(NULL); }

  Role_Model* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Role_Model& from);
  void MergeFrom(const Role_Model& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Role_Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  ::google::protobuf::int32 head() const;
  void set_head(::google::protobuf::int32 value);

  // required int32 Body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  ::google::protobuf::int32 body() const;
  void set_body(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.Gate.G2C.Role_Model)
 private:
  void set_has_head();
  void clear_has_head();
  void set_has_body();
  void clear_has_body();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 head_;
  ::google::protobuf::int32 body_;
  friend struct ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::TableStruct;
  friend void ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::InitDefaultsRole_ModelImpl();
};
// -------------------------------------------------------------------

class Role_Info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocol.Gate.G2C.Role_Info) */ {
 public:
  Role_Info();
  virtual ~Role_Info();

  Role_Info(const Role_Info& from);

  inline Role_Info& operator=(const Role_Info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Role_Info(Role_Info&& from) noexcept
    : Role_Info() {
    *this = ::std::move(from);
  }

  inline Role_Info& operator=(Role_Info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role_Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Role_Info* internal_default_instance() {
    return reinterpret_cast<const Role_Info*>(
               &_Role_Info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Role_Info* other);
  friend void swap(Role_Info& a, Role_Info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Role_Info* New() const PROTOBUF_FINAL { return New(NULL); }

  Role_Info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Role_Info& from);
  void MergeFrom(const Role_Info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Role_Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Protocol.Gate.G2C.Role_BaseInfo BaseInfo = 1;
  bool has_baseinfo() const;
  void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  const ::Protocol::Gate::G2C::Role_BaseInfo& baseinfo() const;
  ::Protocol::Gate::G2C::Role_BaseInfo* release_baseinfo();
  ::Protocol::Gate::G2C::Role_BaseInfo* mutable_baseinfo();
  void set_allocated_baseinfo(::Protocol::Gate::G2C::Role_BaseInfo* baseinfo);

  // @@protoc_insertion_point(class_scope:Protocol.Gate.G2C.Role_Info)
 private:
  void set_has_baseinfo();
  void clear_has_baseinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Protocol::Gate::G2C::Role_BaseInfo* baseinfo_;
  friend struct ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::TableStruct;
  friend void ::protobuf_Gate_2fProtocol_2fGC_2ecode_2eproto::InitDefaultsRole_InfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MSG_G2C_Heartbeat

// required int32 UId = 1;
inline bool MSG_G2C_Heartbeat::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_G2C_Heartbeat::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_G2C_Heartbeat::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_G2C_Heartbeat::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 MSG_G2C_Heartbeat::uid() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.MSG_G2C_Heartbeat.UId)
  return uid_;
}
inline void MSG_G2C_Heartbeat::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.MSG_G2C_Heartbeat.UId)
}

// -------------------------------------------------------------------

// MSG_G2C_EncryptKey

// required string EncryptKey = 1;
inline bool MSG_G2C_EncryptKey::has_encryptkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_G2C_EncryptKey::set_has_encryptkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_G2C_EncryptKey::clear_has_encryptkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_G2C_EncryptKey::clear_encryptkey() {
  encryptkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encryptkey();
}
inline const ::std::string& MSG_G2C_EncryptKey::encryptkey() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
  return encryptkey_.GetNoArena();
}
inline void MSG_G2C_EncryptKey::set_encryptkey(const ::std::string& value) {
  set_has_encryptkey();
  encryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
}
#if LANG_CXX11
inline void MSG_G2C_EncryptKey::set_encryptkey(::std::string&& value) {
  set_has_encryptkey();
  encryptkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
}
#endif
inline void MSG_G2C_EncryptKey::set_encryptkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_encryptkey();
  encryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
}
inline void MSG_G2C_EncryptKey::set_encryptkey(const char* value, size_t size) {
  set_has_encryptkey();
  encryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
}
inline ::std::string* MSG_G2C_EncryptKey::mutable_encryptkey() {
  set_has_encryptkey();
  // @@protoc_insertion_point(field_mutable:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
  return encryptkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MSG_G2C_EncryptKey::release_encryptkey() {
  // @@protoc_insertion_point(field_release:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
  clear_has_encryptkey();
  return encryptkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MSG_G2C_EncryptKey::set_allocated_encryptkey(::std::string* encryptkey) {
  if (encryptkey != NULL) {
    set_has_encryptkey();
  } else {
    clear_has_encryptkey();
  }
  encryptkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encryptkey);
  // @@protoc_insertion_point(field_set_allocated:Protocol.Gate.G2C.MSG_G2C_EncryptKey.EncryptKey)
}

// -------------------------------------------------------------------

// MSG_G2C_Login

// required int32 Result = 1;
inline bool MSG_G2C_Login::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_G2C_Login::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_G2C_Login::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_G2C_Login::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 MSG_G2C_Login::result() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.MSG_G2C_Login.Result)
  return result_;
}
inline void MSG_G2C_Login::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.MSG_G2C_Login.Result)
}

// repeated .Protocol.Gate.G2C.Role_BaseInfo RoleList = 2;
inline int MSG_G2C_Login::rolelist_size() const {
  return rolelist_.size();
}
inline void MSG_G2C_Login::clear_rolelist() {
  rolelist_.Clear();
}
inline const ::Protocol::Gate::G2C::Role_BaseInfo& MSG_G2C_Login::rolelist(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.MSG_G2C_Login.RoleList)
  return rolelist_.Get(index);
}
inline ::Protocol::Gate::G2C::Role_BaseInfo* MSG_G2C_Login::mutable_rolelist(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.Gate.G2C.MSG_G2C_Login.RoleList)
  return rolelist_.Mutable(index);
}
inline ::Protocol::Gate::G2C::Role_BaseInfo* MSG_G2C_Login::add_rolelist() {
  // @@protoc_insertion_point(field_add:Protocol.Gate.G2C.MSG_G2C_Login.RoleList)
  return rolelist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::Gate::G2C::Role_BaseInfo >*
MSG_G2C_Login::mutable_rolelist() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.Gate.G2C.MSG_G2C_Login.RoleList)
  return &rolelist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::Gate::G2C::Role_BaseInfo >&
MSG_G2C_Login::rolelist() const {
  // @@protoc_insertion_point(field_list:Protocol.Gate.G2C.MSG_G2C_Login.RoleList)
  return rolelist_;
}

// -------------------------------------------------------------------

// MSG_G2C_CreateRole

// required int32 Result = 1;
inline bool MSG_G2C_CreateRole::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSG_G2C_CreateRole::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MSG_G2C_CreateRole::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MSG_G2C_CreateRole::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 MSG_G2C_CreateRole::result() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.MSG_G2C_CreateRole.Result)
  return result_;
}
inline void MSG_G2C_CreateRole::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.MSG_G2C_CreateRole.Result)
}

// required .Protocol.Gate.G2C.Role_BaseInfo Role = 2;
inline bool MSG_G2C_CreateRole::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_G2C_CreateRole::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_G2C_CreateRole::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_G2C_CreateRole::clear_role() {
  if (role_ != NULL) role_->Clear();
  clear_has_role();
}
inline const ::Protocol::Gate::G2C::Role_BaseInfo& MSG_G2C_CreateRole::role() const {
  const ::Protocol::Gate::G2C::Role_BaseInfo* p = role_;
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.MSG_G2C_CreateRole.Role)
  return p != NULL ? *p : *reinterpret_cast<const ::Protocol::Gate::G2C::Role_BaseInfo*>(
      &::Protocol::Gate::G2C::_Role_BaseInfo_default_instance_);
}
inline ::Protocol::Gate::G2C::Role_BaseInfo* MSG_G2C_CreateRole::release_role() {
  // @@protoc_insertion_point(field_release:Protocol.Gate.G2C.MSG_G2C_CreateRole.Role)
  clear_has_role();
  ::Protocol::Gate::G2C::Role_BaseInfo* temp = role_;
  role_ = NULL;
  return temp;
}
inline ::Protocol::Gate::G2C::Role_BaseInfo* MSG_G2C_CreateRole::mutable_role() {
  set_has_role();
  if (role_ == NULL) {
    role_ = new ::Protocol::Gate::G2C::Role_BaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:Protocol.Gate.G2C.MSG_G2C_CreateRole.Role)
  return role_;
}
inline void MSG_G2C_CreateRole::set_allocated_role(::Protocol::Gate::G2C::Role_BaseInfo* role) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete role_;
  }
  if (role) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      role = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    set_has_role();
  } else {
    clear_has_role();
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Gate.G2C.MSG_G2C_CreateRole.Role)
}

// -------------------------------------------------------------------

// Role_BaseInfo

// required int32 Id = 1;
inline bool Role_BaseInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Role_BaseInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Role_BaseInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Role_BaseInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Role_BaseInfo::id() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_BaseInfo.Id)
  return id_;
}
inline void Role_BaseInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.Role_BaseInfo.Id)
}

// required string Name = 2;
inline bool Role_BaseInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role_BaseInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role_BaseInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role_BaseInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Role_BaseInfo::name() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_BaseInfo.Name)
  return name_.GetNoArena();
}
inline void Role_BaseInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.Role_BaseInfo.Name)
}
#if LANG_CXX11
inline void Role_BaseInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Protocol.Gate.G2C.Role_BaseInfo.Name)
}
#endif
inline void Role_BaseInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Protocol.Gate.G2C.Role_BaseInfo.Name)
}
inline void Role_BaseInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Protocol.Gate.G2C.Role_BaseInfo.Name)
}
inline ::std::string* Role_BaseInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Protocol.Gate.G2C.Role_BaseInfo.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Role_BaseInfo::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.Gate.G2C.Role_BaseInfo.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Role_BaseInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Protocol.Gate.G2C.Role_BaseInfo.Name)
}

// required int32 Sex = 3;
inline bool Role_BaseInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Role_BaseInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Role_BaseInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Role_BaseInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 Role_BaseInfo::sex() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_BaseInfo.Sex)
  return sex_;
}
inline void Role_BaseInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.Role_BaseInfo.Sex)
}

// required int32 Level = 4;
inline bool Role_BaseInfo::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Role_BaseInfo::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Role_BaseInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Role_BaseInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Role_BaseInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_BaseInfo.Level)
  return level_;
}
inline void Role_BaseInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.Role_BaseInfo.Level)
}

// required .Protocol.Gate.G2C.Role_Model Model = 5;
inline bool Role_BaseInfo::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role_BaseInfo::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role_BaseInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role_BaseInfo::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::Protocol::Gate::G2C::Role_Model& Role_BaseInfo::model() const {
  const ::Protocol::Gate::G2C::Role_Model* p = model_;
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_BaseInfo.Model)
  return p != NULL ? *p : *reinterpret_cast<const ::Protocol::Gate::G2C::Role_Model*>(
      &::Protocol::Gate::G2C::_Role_Model_default_instance_);
}
inline ::Protocol::Gate::G2C::Role_Model* Role_BaseInfo::release_model() {
  // @@protoc_insertion_point(field_release:Protocol.Gate.G2C.Role_BaseInfo.Model)
  clear_has_model();
  ::Protocol::Gate::G2C::Role_Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::Protocol::Gate::G2C::Role_Model* Role_BaseInfo::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    model_ = new ::Protocol::Gate::G2C::Role_Model;
  }
  // @@protoc_insertion_point(field_mutable:Protocol.Gate.G2C.Role_BaseInfo.Model)
  return model_;
}
inline void Role_BaseInfo::set_allocated_model(::Protocol::Gate::G2C::Role_Model* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Gate.G2C.Role_BaseInfo.Model)
}

// -------------------------------------------------------------------

// Role_Model

// required int32 Head = 1;
inline bool Role_Model::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role_Model::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role_Model::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role_Model::clear_head() {
  head_ = 0;
  clear_has_head();
}
inline ::google::protobuf::int32 Role_Model::head() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_Model.Head)
  return head_;
}
inline void Role_Model::set_head(::google::protobuf::int32 value) {
  set_has_head();
  head_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.Role_Model.Head)
}

// required int32 Body = 2;
inline bool Role_Model::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role_Model::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role_Model::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role_Model::clear_body() {
  body_ = 0;
  clear_has_body();
}
inline ::google::protobuf::int32 Role_Model::body() const {
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_Model.Body)
  return body_;
}
inline void Role_Model::set_body(::google::protobuf::int32 value) {
  set_has_body();
  body_ = value;
  // @@protoc_insertion_point(field_set:Protocol.Gate.G2C.Role_Model.Body)
}

// -------------------------------------------------------------------

// Role_Info

// required .Protocol.Gate.G2C.Role_BaseInfo BaseInfo = 1;
inline bool Role_Info::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role_Info::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role_Info::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role_Info::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->Clear();
  clear_has_baseinfo();
}
inline const ::Protocol::Gate::G2C::Role_BaseInfo& Role_Info::baseinfo() const {
  const ::Protocol::Gate::G2C::Role_BaseInfo* p = baseinfo_;
  // @@protoc_insertion_point(field_get:Protocol.Gate.G2C.Role_Info.BaseInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::Protocol::Gate::G2C::Role_BaseInfo*>(
      &::Protocol::Gate::G2C::_Role_BaseInfo_default_instance_);
}
inline ::Protocol::Gate::G2C::Role_BaseInfo* Role_Info::release_baseinfo() {
  // @@protoc_insertion_point(field_release:Protocol.Gate.G2C.Role_Info.BaseInfo)
  clear_has_baseinfo();
  ::Protocol::Gate::G2C::Role_BaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline ::Protocol::Gate::G2C::Role_BaseInfo* Role_Info::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) {
    baseinfo_ = new ::Protocol::Gate::G2C::Role_BaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:Protocol.Gate.G2C.Role_Info.BaseInfo)
  return baseinfo_;
}
inline void Role_Info::set_allocated_baseinfo(::Protocol::Gate::G2C::Role_BaseInfo* baseinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete baseinfo_;
  }
  if (baseinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      baseinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baseinfo, submessage_arena);
    }
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  baseinfo_ = baseinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Gate.G2C.Role_Info.BaseInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace G2C
}  // namespace Gate
}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Gate_2fProtocol_2fGC_2ecode_2eproto__INCLUDED
